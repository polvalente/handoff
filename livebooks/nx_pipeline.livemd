# Untitled notebook

```elixir
Mix.install([
  {:nx, path: "/Users/valente/coding/nx/nx"},
  {:handoff, path: "/Users/valente/coding/handoff"}
])
```

## Section

```elixir
defmodule Mod do
  import Nx.Defn

  defn my_function(x, y) do
    c = Nx.cos(x)
    s = Nx.sin(y)

    c + s
  end

  def compile_and_call_expr(args, expr) do
    Nx.Defn.jit_apply(fn _ -> expr end, [args])
  end

  def load_from_file(filename, index) do
    filename
    |> File.read!()
    |> Nx.deserialize()
    |> elem(index)
  end

  def arg_list_to_tuple(arg1, arg2), do: {arg1, arg2}
end

expr = Nx.Defn.debug_expr(&Mod.my_function/2).(Nx.template({10}, :f32), 1)
```

```elixir
nx_graph = Nx.Defn.Graph.split(expr, fn %{data: %{op: op}} -> op == :add end)
```

```elixir
nx_stage_to_functions = fn stage ->
  args =
    Enum.map(stage.arguments, fn
      %{source: {nil, idx}} ->
        %Handoff.Function{
          id: {stage.id, nil, idx},
          args: [],
          code: &Mod.load_from_file/2,
          extra_args: ["/Users/valente/Desktop/inputs.nx", idx],
          type: :inline
        }

      %{source: {id, idx}} ->
        %Handoff.Function{
          id: {stage.id, id, idx},
          args: [id],
          code: &Kernel.elem/2,
          extra_args: [idx]
        }
    end)

  arg_ids = Enum.map(args, & &1.id)

  [
    %Handoff.Function{
      id: stage.id,
      args: [{stage.id, :args}],
      code: &Mod.compile_and_call_expr/2,
      extra_args: [stage.expr]
    },
    %Handoff.Function{
      id: {stage.id, :args},
      args: arg_ids,
      code: &Mod.arg_list_to_tuple/2,
      extra_args: []
    }
    | args
  ]
end

dag = Enum.flat_map(nx_graph, nx_stage_to_functions) |> Enum.reduce(Handoff.DAG.new(), &Handoff.DAG.add_function(&2, &1))
```

```elixir
{:ok, %{results: results}} = Handoff.execute(dag)

results[List.last(nx_graph).id]
```
