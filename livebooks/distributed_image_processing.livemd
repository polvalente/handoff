# Distributed Image Processing Example

## Introduction

This example demonstrates using Handout for distributed image processing across multiple Erlang nodes. The pipeline loads images, applies various transformations, and creates a collage of the results. Each operation can be distributed across the available nodes based on resource requirements.

## Setup

First, let's set up the environment:

```elixir
Mix.install([
  {:handout, path: Path.join(__DIR__, ".."},
  {:image, "~> 0.14"} # For actual image processing
])
```

## Image Transformations Module

This module simulates image processing operations. In a real application, you would use actual image processing libraries.

```elixir
defmodule ImageTransformations do
  @moduledoc """
  Image transformation functions for the distributed processing example.

  This module provides functions that would be used in a real image processing
  pipeline. For simplicity, this example doesn't require actual image libraries
  and uses placeholder functions.

  In a real application, you would use libraries like:
  - https://hexdocs.pm/image/readme.html
  - https://github.com/elixir-nx/nx for tensor operations
  """

  @doc """
  Simulates loading an image from disk.
  In a real application, this would load actual image data.
  """
  def load_image(path) do
    # Simulate loading time
    Process.sleep(100)

    # Return a simulated image structure
    %{
      path: path,
      filename: Path.basename(path),
      width: Enum.random(800..1200),
      height: Enum.random(600..900),
      data: :crypto.strong_rand_bytes(100),  # Simulated image data
      format: Enum.random([:jpg, :png, :gif]),
      metadata: %{loaded_on: DateTime.utc_now()}
    }
  end

  @doc """
  Simulates resizing an image to the specified dimensions.
  """
  def resize_image(image, width, height) do
    # Simulate CPU-intensive operation
    Process.sleep(300)

    %{image |
      width: width,
      height: height,
      metadata: Map.put(image.metadata, :resized, true)
    }
  end

  @doc """
  Simulates applying a blur filter to an image.
  """
  def blur_image(image, radius \\ 5) do
    # Simulate processing time based on image size and blur radius
    processing_time = div(image.width * image.height, 100_000) * radius
    Process.sleep(processing_time)

    %{image |
      metadata: Map.put(image.metadata, :blur_applied, radius)
    }
  end

  @doc """
  Simulates converting an image to grayscale.
  """
  def grayscale(image) do
    # Simulate processing time
    Process.sleep(200)

    %{image |
      metadata: Map.put(image.metadata, :grayscale, true)
    }
  end

  @doc """
  Simulates applying a sepia filter.
  """
  def sepia(image) do
    # Simulate processing time
    Process.sleep(250)

    %{image |
      metadata: Map.put(image.metadata, :sepia, true)
    }
  end

  @doc """
  Simulates edge detection on an image.
  """
  def edge_detection(image) do
    # Simulate GPU-intensive operation
    Process.sleep(400)

    %{image |
      metadata: Map.put(image.metadata, :edge_detection, true)
    }
  end

  @doc """
  Simulates creating a thumbnail of an image.
  """
  def create_thumbnail(image, size \\ 150) do
    # Simulate processing
    Process.sleep(150)

    %{image |
      width: size,
      height: size,
      metadata: Map.put(image.metadata, :thumbnail, true)
    }
  end

  @doc """
  Simulates creating a collage from multiple images.
  """
  def create_collage(images, options \\ []) do
    # Simulate complex operation
    Process.sleep(500 + length(images) * 50)

    %{
      type: :collage,
      source_images: length(images),
      width: Keyword.get(options, :width, 1200),
      height: Keyword.get(options, :height, 800),
      data: :crypto.strong_rand_bytes(200),
      created_at: DateTime.utc_now()
    }
  end

  @doc """
  Simulates saving an image to disk.
  """
  def save_image(image, output_path) do
    # Simulate disk I/O
    Process.sleep(200)

    # Return path where image was "saved"
    %{
      original: image,
      saved_path: output_path,
      timestamp: DateTime.utc_now()
    }
  end

  @doc """
  Simulates image quality assessment.
  """
  def assess_quality(image) do
    # Simulate analysis
    Process.sleep(300)

    metrics = %{
      sharpness: :rand.uniform() * 10,
      noise_level: :rand.uniform() * 5,
      exposure: :rand.uniform() * 10,
      color_balance: :rand.uniform() * 10
    }

    {image, metrics}
  end
end
```

## Node Setup and Discovery

> **Note**: This section requires running multiple nodes. If you're running this in Livebook, you can skip to the "Pipeline Implementation" section and run it in single-node mode.

To run as a true distributed system, start multiple nodes in separate terminals:

```bash
# Terminal 1
iex --name node1@127.0.0.1 -S mix

# Terminal 2
iex --name node2@127.0.0.1 -S mix

# Terminal 3 (optional)
iex --name node3@127.0.0.1 -S mix
```

Then connect the nodes from node1:

```elixir
# Run this in node1
Node.connect(:"node2@127.0.0.1")
Node.connect(:"node3@127.0.0.1")
Node.list()
```

## Pipeline Implementation

```elixir
defmodule DistributedImageProcessing do
  @moduledoc """
  Example of distributed image processing using Handout.
  """

  alias Handout.Function

  @doc """
  Build the image processing pipeline DAG.
  """
  def build_pipeline(image_paths) do
    dag = Handout.new()

    # 1. Load images function
    load_images_fn = %Function{
      id: :load_images,
      args: [],
      code: fn ->
        IO.puts("Loading #{length(image_paths)} images...")
        image_paths |> Enum.map(&{&1, ImageTransformations.load_image(&1)}) |> Enum.into(%{})
      end,
      cost: %{cpu: 1, memory: 500}  # Light CPU, moderate memory
    }

    # 2. Resize images function
    resize_fn = %Function{
      id: :resize_images,
      args: [:load_images],
      code: fn %{load_images: images} ->
        IO.puts("Resizing images...")
        images |> Enum.map(fn {path, img} ->
          {path, ImageTransformations.resize_image(img, 800, 600)}
        end) |> Enum.into(%{})
      end,
      cost: %{cpu: 2, memory: 1000}  # Moderate CPU
    }

    # 3a. Apply grayscale effect
    grayscale_fn = %Function{
      id: :grayscale_effect,
      args: [:resize_images],
      code: fn %{resize_images: images} ->
        IO.puts("Applying grayscale effect...")
        images |> Enum.map(fn {path, img} ->
          {path, ImageTransformations.grayscale(img)}
        end) |> Enum.into(%{})
      end,
      cost: %{cpu: 2, memory: 800}  # Moderate CPU
    }

    # 3b. Apply sepia effect (parallel branch)
    sepia_fn = %Function{
      id: :sepia_effect,
      args: [:resize_images],
      code: fn %{resize_images: images} ->
        IO.puts("Applying sepia effect...")
        images |> Enum.map(fn {path, img} ->
          {path, ImageTransformations.sepia(img)}
        end) |> Enum.into(%{})
      end,
      cost: %{cpu: 2, memory: 800}  # Moderate CPU
    }

    # 3c. Apply blur effect (parallel branch)
    blur_fn = %Function{
      id: :blur_effect,
      args: [:resize_images],
      code: fn %{resize_images: images} ->
        IO.puts("Applying blur effect...")
        images |> Enum.map(fn {path, img} ->
          {path, ImageTransformations.blur_image(img)}
        end) |> Enum.into(%{})
      end,
      cost: %{cpu: 3, memory: 1200}  # Higher CPU, more memory
    }

    # 3d. Apply edge detection (GPU intensive)
    edge_fn = %Function{
      id: :edge_detection,
      args: [:resize_images],
      code: fn %{resize_images: images} ->
        IO.puts("Applying edge detection...")
        images |> Enum.map(fn {path, img} ->
          {path, ImageTransformations.edge_detection(img)}
        end) |> Enum.into(%{})
      end,
      cost: %{cpu: 2, memory: 1500, gpu: 1}  # Needs GPU
    }

    # 4. Create thumbnails
    thumbnail_fn = %Function{
      id: :create_thumbnails,
      args: [:resize_images],
      code: fn %{resize_images: images} ->
        IO.puts("Creating thumbnails...")
        images |> Enum.map(fn {path, img} ->
          {path, ImageTransformations.create_thumbnail(img)}
        end) |> Enum.into(%{})
      end,
      cost: %{cpu: 1, memory: 500}  # Light work
    }

    # 5. Quality assessment on different effects
    quality_assessment_fn = %Function{
      id: :quality_report,
      args: [:grayscale_effect, :sepia_effect, :blur_effect, :edge_detection],
      code: fn results ->
        IO.puts("Assessing image quality across effects...")

        # Combine all effect results
        all_effects = %{
          grayscale: results.grayscale_effect,
          sepia: results.sepia_effect,
          blur: results.blur_effect,
          edge: results.edge_detection
        }

        # Assess quality for each effect and image
        all_effects |> Enum.flat_map(fn {effect, images} ->
          images |> Enum.map(fn {path, img} ->
            {"#{effect}_#{Path.basename(path)}", ImageTransformations.assess_quality(img)}
          end)
        end) |> Enum.into(%{})
      end,
      cost: %{cpu: 4, memory: 2000}  # CPU intensive analysis
    }

    # 6. Create collage from effects
    collage_fn = %Function{
      id: :create_collage,
      args: [:grayscale_effect, :sepia_effect, :blur_effect, :edge_detection],
      code: fn results ->
        IO.puts("Creating collage from all effects...")

        # Extract all images from different effects
        all_images =
          results.grayscale_effect |> Map.values() |>
          Enum.concat(Map.values(results.sepia_effect)) |>
          Enum.concat(Map.values(results.blur_effect)) |>
          Enum.concat(Map.values(results.edge_detection))

        # Create the collage
        ImageTransformations.create_collage(all_images, width: 1600, height: 1200)
      end,
      cost: %{cpu: 4, memory: 4000}  # Heavy CPU and memory
    }

    # 7. Save thumbnails
    save_thumbnails_fn = %Function{
      id: :save_thumbnails,
      args: [:create_thumbnails],
      code: fn %{create_thumbnails: thumbnails} ->
        IO.puts("Saving thumbnails...")
        thumbnails |> Enum.map(fn {path, img} ->
          output_path = "output/thumb_#{Path.basename(path)}"
          {path, ImageTransformations.save_image(img, output_path)}
        end) |> Enum.into(%{})
      end,
      cost: %{cpu: 1, memory: 500}  # I/O bound
    }

    # 8. Save collage
    save_collage_fn = %Function{
      id: :save_collage,
      args: [:create_collage],
      code: fn %{create_collage: collage} ->
        IO.puts("Saving final collage...")
        output_path = "output/collage_#{DateTime.utc_now() |> DateTime.to_unix()}.jpg"
        ImageTransformations.save_image(collage, output_path)
      end,
      cost: %{cpu: 1, memory: 500}  # I/O bound
    }

    # Build the DAG
    dag
    |> Handout.DAG.add_function(load_images_fn)
    |> Handout.DAG.add_function(resize_fn)
    |> Handout.DAG.add_function(grayscale_fn)
    |> Handout.DAG.add_function(sepia_fn)
    |> Handout.DAG.add_function(blur_fn)
    |> Handout.DAG.add_function(edge_fn)
    |> Handout.DAG.add_function(thumbnail_fn)
    |> Handout.DAG.add_function(quality_assessment_fn)
    |> Handout.DAG.add_function(collage_fn)
    |> Handout.DAG.add_function(save_thumbnails_fn)
    |> Handout.DAG.add_function(save_collage_fn)
  end

  @doc """
  Run the distributed image processing pipeline.
  """
  def run do
    # Start Handout
    Handout.start()

    # Register the local node with capabilities
    IO.puts("Registering local node capabilities...")
    Handout.register_local_node(%{
      cpu: 8,         # 8 CPU cores
      memory: 16000,  # 16GB RAM
      gpu: 1          # 1 GPU
    })

    # Discover other nodes in the cluster
    {:ok, discovered_nodes} = Handout.discover_nodes()
    IO.puts("Discovered nodes: #{inspect Map.keys(discovered_nodes)}")

    # Simulate image paths (would be real paths in a production app)
    image_paths = Enum.map(1..5, fn i -> "/path/to/image_#{i}.jpg" end)
    IO.puts("Processing #{length(image_paths)} images...")

    # Create a DAG for image processing
    dag = build_pipeline(image_paths)

    # Validate the DAG
    case Handout.DAG.validate(dag) do
      :ok ->
        IO.puts("\nExecuting distributed image processing pipeline...\n")

        # Execute the DAG across all available nodes
        case Handout.execute_distributed(dag,
          allocation_strategy: :cost_optimized,
          max_retries: 2
        ) do
          {:ok, results} ->
            # Show the saved collage path
            collage_result = results[:save_collage]
            IO.puts("\nPipeline completed successfully!")
            IO.puts("Collage saved to: #{collage_result.saved_path}")

            # Show quality metrics
            metrics = results[:quality_report]
            IO.puts("\nQuality metrics:")
            Enum.each(metrics, fn {image_id, {_img, report}} ->
              IO.puts("  #{image_id}: " <>
                "Sharpness: #{Float.round(report.sharpness, 1)}, " <>
                "Noise: #{Float.round(report.noise_level, 1)}")
            end)

            # Show node allocation statistics
            IO.puts("\nNode allocation:")
            nodes_used = Enum.map(valid_dag.functions, fn {id, func} ->
              {id, func.node}
            end) |> Enum.into(%{})

            node_counts = Enum.reduce(nodes_used, %{}, fn {_id, node}, acc ->
              Map.update(acc, node, 1, &(&1 + 1))
            end)

            Enum.each(node_counts, fn {node, count} ->
              IO.puts("  #{node}: #{count} functions")
            end)

            {:ok, results}

          {:error, reason} ->
            IO.puts("Error executing pipeline: #{inspect(reason)}")
            {:error, reason}
        end

      {:error, reason} ->
        IO.puts("Invalid DAG: #{inspect(reason)}")
        {:error, reason}
    end
  end
end
```

## Running the Pipeline

You can execute the pipeline with:

```elixir
# Run in distributed mode (requires multiple connected nodes)
DistributedImageProcessing.run()

# Or just build without executing to inspect the DAG
image_paths = Enum.map(1..5, fn i -> "/path/to/image_#{i}.jpg" end)
dag = DistributedImageProcessing.build_pipeline(image_paths)
```

## Visualizing the DAG

In a full implementation, you might add a visualization of the DAG. Here's a placeholder for that:

```elixir
# Pseudocode for DAG visualization (not implemented in this example)
# dag |> Handout.Visualization.generate_graph() |> Handout.Visualization.render()
```

## Key Concepts Demonstrated

- Distributed execution across nodes
- Resource-aware function allocation
- Complex DAG with multiple parallel branches
- Resource requirements and allocation
- Load balancing and cost optimization
- Quality assessment and results aggregation
